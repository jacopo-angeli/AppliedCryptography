# #!/usr/bin/env python3

# import codecs, datetime, hashlib, re, sys, socket # do not use any other imports/libraries
# from urllib.parse import urlparse
# from pyasn1.codec.der import decoder, encoder
# from pyasn1.type import namedtype, univ

# # sudo apt install python3-pyasn1-modules
# from pyasn1_modules import rfc2560, rfc5280

# # took x.y hours (please specify here how much time your solution required)

# def ib(i, length=False):
#     # converts integer to bytes
#     b = b''
#     if length==False:
#         length = (i.bit_length()+7)//8
#     for _ in range(length):
#         b = bytes([i & 0xff]) + b
#         i >>= 8
#     return b

# def bi(b):
#     # converts bytes to integer
#     i = 0
#     for byte in b:
#         i <<= 8
#         i |= byte
#     return i

# #==== ASN1 encoder start ====
# # put your DER encoder functions here

# #==== ASN1 encoder end ====


# def pem_to_der(content):
#     # converts PEM-encoded X.509 certificate (if it is in PEM) to DER
#     if content[:2] == b'--':
#         content = content.replace(b"-----BEGIN CERTIFICATE-----", b"")
#         content = content.replace(b"-----END CERTIFICATE-----", b"")
#         content = codecs.decode(content, 'base64')
#     return content

# def get_name(cert):
#     # gets subject DN from certificate
#     return name

# def get_key(cert):
#      # gets subjectPublicKey from certificate
#     return subjectPublicKey

# def get_serial(cert):
#     # gets serial from certificate
#     return serial

# def produce_request(cert, issuer_cert):
#     # makes OCSP request in ASN.1 DER form

#     # construct CertID (use SHA1)
#     issuer_name = get_name(issuer_cert)
#     issuer_key = get_key(issuer_cert)
#     serial = get_serial(cert)

#     print("[+] OCSP request for serial:", serial)

#     # construct entire OCSP request

#     return request

# def send_req(ocsp_req, ocsp_url):
#     # sends OCSP request to OCSP responder

#     # parse OCSP responder's url

#     print("[+] Connecting to %s..." % (host))
#     # connect to host

#     # send HTTP POST request

#     # read HTTP response header

#     # get HTTP response length

#     # read HTTP response body

#     return ocsp_resp

# def get_ocsp_url(cert):
#     # gets the OCSP responder's url from the certificate's AIA extension


#     # pyasn1 syntax description to decode AIA extension
#     class AccessDescription(univ.Sequence):
#       componentType = namedtype.NamedTypes(
#         namedtype.NamedType('accessMethod', univ.ObjectIdentifier()),
#         namedtype.NamedType('accessLocation', rfc5280.GeneralName()))

#     class AuthorityInfoAccessSyntax(univ.SequenceOf):
#       componentType = AccessDescription()

#     # looping over certificate extensions
#     for seq in decoder.decode(cert)[0][0][7]:
#         if str(seq[0])=='1.3.6.1.5.5.7.1.1': # look for AIA extension
#             ext_value = bytes(seq[1])
#             for aia in decoder.decode(ext_value, asn1Spec=AuthorityInfoAccessSyntax())[0]:
#                 if str(aia[0])=='1.3.6.1.5.5.7.48.1': # ocsp url
#                     return str(aia[1].getComponentByName('uniformResourceIdentifier'))

#     print("[-] OCSP url not found in the certificate!")
#     exit(1)

# def get_issuer_cert_url(cert):
#     # gets the CA's certificate URL from the certificate's AIA extension (hint: see get_ocsp_url())

#     pass

# def download_issuer_cert(issuer_cert_url):
#     # downloads issuer certificate
#     print("[+] Downloading issuer certificate from:", issuer_cert_url)

#     # parse issuer certificate url
#     url = urlparse(issuer_cert_url)

#     # connect to host

#     # send HTTP GET request

#     # read HTTP response header

#     # get HTTP response length

#     # read HTTP response body

#     return issuer_cert

# def parse_ocsp_resp(ocsp_resp):
#     # parses OCSP response
#     ocspResponse, _ = decoder.decode(ocsp_resp, asn1Spec=rfc2560.OCSPResponse())
#     responseStatus = ocspResponse.getComponentByName('responseStatus')
#     assert responseStatus == rfc2560.OCSPResponseStatus('successful'), responseStatus.prettyPrint()
#     responseBytes = ocspResponse.getComponentByName('responseBytes')
#     responseType = responseBytes.getComponentByName('responseType')
#     assert responseType == rfc2560.id_pkix_ocsp_basic, responseType.prettyPrint()

#     response = responseBytes.getComponentByName('response')

#     basicOCSPResponse, _ = decoder.decode(
#         response, asn1Spec=rfc2560.BasicOCSPResponse()
#     )

#     tbsResponseData = basicOCSPResponse.getComponentByName('tbsResponseData')

#     response0 = tbsResponseData.getComponentByName('responses').getComponentByPosition(0)

#     producedAt = datetime.datetime.strptime(str(tbsResponseData.getComponentByName('producedAt')), '%Y%m%d%H%M%SZ')
#     certID = response0.getComponentByName('certID')
#     certStatus = response0.getComponentByName('certStatus').getName()
#     thisUpdate = datetime.datetime.strptime(str(response0.getComponentByName('thisUpdate')), '%Y%m%d%H%M%SZ')
#     nextUpdate = datetime.datetime.strptime(str(response0.getComponentByName('nextUpdate')), '%Y%m%d%H%M%SZ')

#     # let's assume that the certID in the response matches the certID sent in the request

#     # let's assume that the response is signed by a trusted responder

#     print("[+] OCSP producedAt: %s +00:00" % producedAt)
#     print("[+] OCSP thisUpdate: %s +00:00" % thisUpdate)
#     print("[+] OCSP nextUpdate: %s +00:00" % nextUpdate)
#     print("[+] OCSP status:", certStatus)

# cert = pem_to_der(open(sys.argv[1], 'rb').read())

# ocsp_url = get_ocsp_url(cert)
# print("[+] URL of OCSP responder:", ocsp_url)

# issuer_cert_url = get_issuer_cert_url(cert)
# issuer_cert = download_issuer_cert(issuer_cert_url)

# ocsp_req = produce_request(cert, issuer_cert)
# ocsp_resp = send_req(ocsp_req, ocsp_url)
# parse_ocsp_resp(ocsp_resp)
